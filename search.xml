<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js截取字符串(区分中文/英文)]]></title>
    <url>%2F2018%2F07%2F18%2FstringFn%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829/* 处理过长的字符串，截取并添加省略号 * 注：半角长度为1，全角长度为2 * str:字符串 * len:截取长度 * return: 截取后的字符串 */function cutbytestr(str, len) &#123; var str_length = 0; var str_len = 0; str_cut = new String(); str_len = str.length; for (var i = 0; i &lt; str_len; i++) &#123; a = str.charAt(i); str_length++; if (escape(a).length &gt; 4) &#123; //中文字符的长度经编码之后大于4 str_length++; &#125; str_cut = str_cut.concat(a); if (str_length &gt;= len) &#123; str_cut = str_cut.concat("…"); return str_cut; &#125; &#125; //如果给定字符串小于指定长度，则返回源字符串； if (str_length &lt; len) &#123; return str; &#125;&#125; 1234567891011121314151617/* 处理过长的字符串，截取并添加省略号 * str:字符串 * len:截取长度 * return: 截取后的字符串 */function cutstr(str, len) &#123; var str_length = 0; var str_len = 0; str_len=str.length; if (str_len &lt;= len) &#123; return str; &#125;else&#123; str=str.substr(0,len); str = str.concat("…"); return str; &#125;&#125; 123456789/* 取字符串长度 * 注：汉字算两个字符，英文算一个字符 * str:字符串 * return: 长度 */function getStrLength(str) &#123; var cArr = str.match(/[^\x00-\xff]/ig); return str.length + (cArr == null ? 0 : cArr.length);&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数]]></title>
    <url>%2F2018%2F05%2F02%2Fes6-10%2F</url>
    <content type="text"><![CDATA[为箭头函数指定默认值es5使用函数想给参数添加默认值的时候可以这样写：123456function fn(a,b)&#123; a = a || 10; b = b || 20; console.log(a + b)&#125;fn(0,10) //20 上面的代码，给a传参数为0，但是判断的时候，0为false,所有得到20，为了解决上面的问题，es6新加入了默认值方法。12345function fn(a = 10,b = 20)&#123; console.log(a + b)&#125;fn() //30fn(0,20) //20 rest参数（…变量名）用于获取函数多余的参数，这样就不需要arguments对象了，rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。123456789function sum()&#123; var args = arguments; var res = 0; for(var i = 0;i &lt; args.length;i++)&#123; res += args[i] &#125; console.log(res)&#125;sum(1,2,3,4,5) //15 使用rest代替arguments。12345678function sum(...arr)&#123; var res = 0; for(var i = 0;i &lt; arr.length;i++)&#123; res += arr[i] &#125; console.log(res)&#125;sum(1,2,3,4,5) //15 rest注意事项：rest前面可以添加参数，但是后面不能添加参数，如果添加了会报错。12345678function sum(a,...arr)&#123; var res = a; for(var i = 0;i &lt; arr.length;i++)&#123; res += arr[i] &#125; console.log(res)&#125;sum(10,1,2,3,4,5) //25 箭头函数=&gt;1234567const fn = a =&gt; a;const fn2 function(a)&#123; return a;&#125;console.log(fn(1)) //1console.log(fn2(1)) //1 多个参数12const fn = (a , b) =&gt; a + b;console.log(fn(1,2)) //3 多行代码123456const fn = (a , b) =&gt; &#123; a = a * 2; b = b * 2; return a + b;&#125;console.log(fn(1,2)) //6 箭头返回值是对象的时候，需要用()包裹起来12const fn = (a , b) =&gt; (&#123;a , b&#125;);console.log(fn(1,2)) //&#123;a : 1,b : 2&#125; 箭头函数内没有自己的this对象，所有在使用的时候，其内部的this就是其定义的所在环境的对象，而不是使用时所在的对象。12345678910function fn()&#123; setTimeout(function()&#123; console.log(this) &#125;,1000); setTimeout(() =&gt;&#123; console.log(this) &#125;);&#125;let obj = &#123; a : 1&#125;fn.call(obj) //window,&#123;a : 1&#125; 箭头函数注意事项1.箭头函数不能使用call、apply、bind去改变其内部的this指向。2.箭头函数没有arguments对象，如果要用，可以用rest参数代替。123456789function fn()&#123; setTimeout(()=&gt;&#123; console.log(arguments) &#125;,1000)&#125;fn(1,2,3) //打印出fn的argumentsconst fn = (...arr) =&gt; arr;console.log(fn(1,2,3,4)) //[1,2,3,4] 3.箭头函数不可以当作构造函数，不可以用new命令，否则报错。4.箭头函数不可以用做Generator函数。]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>箭头函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内置对象的扩展]]></title>
    <url>%2F2018%2F04%2F28%2Fes6-9%2F</url>
    <content type="text"><![CDATA[字符串的扩展平时在使用一段html结构的时候，使用:12345let html = '&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;' 这样写的话，浏览器会报错，一般我们通过字符串拼接来使用html结构，但是这样会很麻烦。为了解决这个问题，es6新增了模版字符串。模版字符串，不再适用单引号或者双引号，而是使用 ` 符号:12345let html = `&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;` 模版字符串的拼接12345let html = `&lt;ul&gt; &lt;li&gt;$('首页')&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;` 123456let flg = true;let html = `&lt;ul&gt; &lt;li&gt;$('首页')&lt;/li&gt; &lt;li class="$&#123;flg ? 'show' : 'hide'&#125;"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;` repeat123let str1 = a;let str2 = str1.repeat(3)console.log(str2) //aaa includes()查找字符串中是否存在否某个字符，返回布尔值123let str = 'liuguangkuo'console.log(str.includes('guang')) //tureconsole.log(str.includes('xx')) //false startsWidth()查找字符串中第一个字符是否存在，返回布尔值123let str = 'liuguangkuo'console.log(str.startsWidth('l')) //tureconsole.log(str.startsWidth('i')) //false endsWidth()查找字符串中最后一个字符是否存在，返回布尔值123let str = 'liuguangkuo'console.log(str.endsWidth('o')) //tureconsole.log(str.endsWidth('u')) //false 数组的扩展Array.form()把类数组对象转换成真正的数组123456789&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;let li = document.querySelectAll('li');console.log(Array.isArray(li)); //false，li是类数组let li2 = Array.form(li);console.log(Array.isArray(li2)); //true Array.of()创建一个数组12let a = Array.of(1,2);console.log(a) //[1,2] find()查找数组中符合条件的元素，返回第一个元素，没有找到返回undefined12345const arr = [1,2,3,4]let res = arr.find(function(a)&#123; return a &lt; 2;&#125;)console.log(res); //1 findIndex()查找数组中符合条件的元素，返回复合元素的下标，没有找到返回-112345const arr = [1,2,3,4]let res = arr.findIndex(function(a)&#123; return a &lt; 2;&#125;)console.log(res); //0 fill()对数组进行填充12345let arr = [1,2,3,4]arr.fill('abc') //['abc','abc','abc','abc']let arr2 = [1,2,3,4]arr.fill('abc',1,3) //[1,'abc','abc',4] 对象的扩展对象的简洁表示发12345678910let a = 1;const obj = &#123; a : a;&#125;console.log(obj) //&#123;a : 1&#125;//简写let a = 1;const obj = &#123;a&#125;console.log(obj) //&#123;a : 1&#125; 1234567891011//函数简写const obj = &#123; fn : function()&#123; console.log(1) &#125;, fn2()&#123; console.log(2) &#125;&#125;obj.fn() //1obj.fn2() //2 Object.is() //判断两个数据是否一样(长的一样)，返回布尔值12console.log(Object.is(NaN,NaN)) //trueconsole.log(Object.is(+0,-0)) //false Object.assign() //用于对象的合并，将原对象可枚举的属性复制到目标对象1234let obj1 = &#123;a : 1&#125;;let obj2 = &#123;a : 2 , b : 2, c :3&#125;;let obj3 = &#123;d : 4&#125;console.log(Object.assign(obj1,obj2,obj3)) //&#123;a: 2, b: 2, c: 3, d: 4&#125; 如果合并的对象属性键值相同，那么后面的键值覆盖前面的键值。]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>symbol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[symbol数据类型]]></title>
    <url>%2F2018%2F04%2F28%2Fes6-8%2F</url>
    <content type="text"><![CDATA[什么是symbolsymbol表示独一无二的值，它是js中第7中数据类型。 12//基本数据类型 null undefined Number Boolan String Symbol//引用数据类型 object 创建symbol123456let a = Symbol();console.log(typeof a); //symbollet a = Symbol();let b = Symbol();console.log(a === b) // false symbol函数前不能使用new,否则会报错。原因在于symbol是一个原始类型的值，不是一个对象。 123let a = Symbol();let b = Symbol();console.log(a,b) //Symbol(),Symbol() 这样没办法区分哪个是a,哪个是b,这样时候可以添加参数。123let a = Symbol('a');let b = Symbol('b');console.log(a,b) //Symbol(a),Symbol(b) symbol接受一个字符串做为参数，表示对symbol的描述，主要在控制台显示，或是转化为字符串的时候比较容易区分。1console.log(Symbol('a') === Symbol('a')) //false，参数仅仅只作为描述。 symole数据类型转换123console.log(String(Symbol('a'))) //'Symbol(a)'console.log(Symbol('a').toString()) //'Symbol(a)'console.log(!Symbol()) //false，symbol默认是true symbol不能转换成数字，不能字符串拼接，不能做任何运算。 symbol作为对象的属性名123456789101112let a = Symbol('name');let obj = &#123;&#125;obj[a] = 'liuguangkuo';console.log(obj) //&#123;Symbol(name): "liuguangkuo"&#125;console.log(obj[a]) //liuguangkuolet a = Symbol('name');let obj = &#123; [a] : 'liuguangkuo'&#125;console.log(obj) //&#123;Symbol(name): "liuguangkuo"&#125;console.log(obj[a]) //liuguangkuo 注意事项123456const obj = &#123; [Symbol()] : '123'&#125;console.log(obj) //&#123;Symbol(): "123"&#125;console.log(obj[Symbol()]) // undefinedconsole.log(obj['Symbol()']) // undefined 这样些的话，是拿不到键对应的值的。 12345678910const obj = &#123; [Symbol()] : '123', a : 1, b : 2&#125;for(let i in obj)&#123; console.log(i)&#125;//a//b 不能for-in循环遍历，虽然不能被遍历，但也不是私有属性，可以通过Object.getOwnPropertySymbols方法获得一个对象所有的Symbol属性。1234567const obj = &#123; [Symbol()] : '123', a : 1, b : 2&#125;console.log(Object.getOwnPropertySymbols(obj)) //返回obj下面所有的`symbol`类型，数组类型console.log(obj[Object.getOwnPropertySymbols(obj)[0]]) //123]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>symbol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class的继承]]></title>
    <url>%2F2018%2F04%2F27%2Fes6-7%2F</url>
    <content type="text"><![CDATA[extendsclass可以通过extends关键字实现继承，这比es5通过修改原型链实现继承，要清晰方便的多。123456class point&#123;&#125;class colorPoint extends point&#123;&#125; 上面的代码，定义了一个colorPoint类，该类通过extends方法继承了point所有的属性和方法。但由于没有部署任何代码，所以两个类完全一样，等于复制了一份point类。12345678910class colorPoint&#123; constructor(x,y,color)&#123; super(x,y)//调用父类constructor(x,y) this.color = color; &#125; toString()&#123; return this.color + ' ' + super.toString();//调用父类的toString方法 &#125;&#125; 上面的代码中，constructor方法和toString方法中都出现了super关键字，他在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor中调用super方法，负责新建实例会报错，这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，找不到子类的this对象。在子类的构造函数中，只有调用了super方法，才能使用this关键字，否则会报错。这是因为子类实例的构造，是基于父类实例加工，super才能返回父类实例。1234567891011121314class point&#123; constructor(x,y)&#123; this.x = x; this.y = y; &#125;&#125;class colorPoint extends point&#123; constructor(x,y,color)&#123; this.color = color; //ReferenceError super(x,y); this.color = color; //正确 &#125;&#125; 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class的基础使用]]></title>
    <url>%2F2018%2F04%2F20%2Fes6-6%2F</url>
    <content type="text"><![CDATA[介绍javascript语言中，生成实例对象的传统方法是构造函数，如：12345678function point(x,y)&#123; this.x = x; this.y = y&#125;point.prototype.toString()&#123; return '(' + this.x + ',' + this.y + ')';&#125;var p = new point(1,2); es6提供了新的方法，通过class来定义。基本上class可以看作只是一个语法糖，他的绝大部分功能，es5都可以做道，新的class写法只是让对象原型的方法更加清晰，更像面向对象的语法而已，上面的代码用class改写，如下：123456789class point&#123; constructor(x,y)&#123; this.x = x; this.y = y; &#125; toString ()&#123; retrun '('+ this.x +','+this.y + ')'; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数point，对应es6的point类的构造方法。 point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 es6 的类，完全可以看作构造函数的另一种写法。12345class point&#123; //...&#125;typeof point //'function'point === point.prototype.constructor //true 构造函数的prototype属性，在 eS6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。123456789101112131415161718class point&#123; constructor ()&#123; //... &#125; toString ()&#123; //... &#125; toValue ()&#123; //... &#125;&#125;//等同与point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125; 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。12345678910class point&#123; constructor()&#123; //.. &#125;&#125;Object.assign(point.prototype,&#123; toString() &#123;&#125;, toValue() &#123;&#125;&#125;) 定义在类中的方法是不可枚举的。1console.log(Object.keys(point.prototype)) //[] contructor方法是类的默认方法，通过new命令生成对象实例时，自动调用contructor方法。一个类必须有constructor方法，如果没有定义，一个空的constrctor方法会被默认添加。]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iterator和for-of循环]]></title>
    <url>%2F2018%2F04%2F20%2Fes6-5%2F</url>
    <content type="text"><![CDATA[基础概念在es6中新增了set和map两种数据结构，再加上js原有的数组和对象，这样就有4中数据结构集合，平时还可以组合使用他们，定义自己的数据结构，比如数组的成员是map，map的成员是对象等。这样就需要一个统一的接口机制，来统一的处理数据结构。 iterator就是这样的一个接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了iterator接口，就可以完成遍历操作，而这种遍历操作是依次处理改数据结构中的所有成员。 iterator遍历器的作用：1.为各种不同的数据结构提供统一的访问接口。2.使得所有的数据结构成员能够按某种次序排列。3.es6新增了遍历命令for…of循环，iterator接口主要提供for…of使用。 iterator方法123456789101112131415const arr = [1,2,3];function iterator(arr)&#123; let index = 0; return &#123; next : function()&#123; return index &lt; arr.length ? &#123;value : arr[index++],done: false&#125; : &#123;value : undefined,done : true&#125; &#125; &#125;&#125;const it = inerator(arr);console.log(it.next()) // &#123;value : 1,done : false&#125;console.log(it.next()) // &#123;value : 2,done : false&#125;console.log(it.next()) // &#123;value : 3,done : false&#125;console.log(it.next()) // &#123;value : undefined,done : true&#125; iterator的遍历过程1.创建一个指针对象，指向当前数据结构的起始位置，也就是说，遍历对象本质上就是一个指针对象。2.第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。3.第二次调用指针对象的next方法，可以将指针指向数据结构的第二个成员。4.不断的调用指针对象的next方法，知道它指向数据结构的结束位置。5.每次调用都会返回数据机构当前成员的信息，具体的说，就是返回value和done两个属性的对象，value表示当前属性的值，done表示是否遍历失败，值为布尔值。 自带iterator的数据结构array、set、map这三种数据结构自带iterator，object没有，凡是具有symbol.iterator属性的数据结构都具有iterator接口。 array,set,map的iterator1234567891011const arr = [1,2,3];const set = new Set(['a','b','c']);const map = new Map([['a',1]])const itarr = arr[Symbol.iterator]()const itset = set[Symbol.iterator]()const itmap = map[Symbol.iterator]()console.log(itarr)console.log(itset)console.log(itmap) 对象没有iterator12const obj = &#123;'a' : 1&#125;console.log(obj[Symbol.iterator]) //undefined 自带iterator的数据结构可以进行结构赋值123const set = new Set([1,2,3])const [x,y] = set;console.log(x,y) // 1,2 自带iterator的数据结构可以扩展运算符（…）1234567const str = 'xiao';const arrstr = [...str]console.log(attstr) //['x','i','a','o']//使用...数组去重复const arr = [1,2,3,1,2,3,4,5,6,5,5,4]console.log([...new Set(arr)]) //[1, 2, 3, 4, 5, 6] for-of循环，具备iterator的数据结构，都可以使用for-of循环for-of语法123456789const arr = ['a','b','c'];for(let i of arr)&#123; console.log(i)&#125;执行结果：abc 1234567891011121314151617const map = new Map([['one','1'],['two','2'],['three','3']])for(let data of map)&#123; console.log(data)&#125;执行结果：["one", "1"]["two", "2"]["three", "3"]for(let [key,value] of map)&#123; console.log(key,value)&#125;执行结果：one,1two,2three,3]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>iterator</tag>
        <tag>for-of</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map数据结构]]></title>
    <url>%2F2018%2F04%2F19%2Fes6-4%2F</url>
    <content type="text"><![CDATA[创建map12345const a = new Map([ ['a',1], ['b',2]])console.log(a) map的属性1console.log(a.size) //2 map的方法1.map.set(key,value),设置key对应的value值，然后返回map结构，如果key已经有值，则更新，否则生成新改key123const a = new Map([['one',1],['two',2]])a.set('three',3)a.set('four',4).set('five',5) 2.map.get(key),获取key对应的value值，如果没有，返回undefined123const a = new Map([['one',1],['two',2]])console.log(a.get('one')) //1console.log(a.get('three')) //undefined 3.map.delete(key),删除某个key，成功返回true，失败返回false12345const a = new Map([['one',1],['two',2]])console.log(a.delete('one')) //true//再次执行删除console.log(a.delete('one')) //false 上面已经删除过了one,所有删除失败 4.map.has(key),返回布尔值，表示key是否存在123const a = new Map([['one',1],['two',2]])console.log(a.has('one')) //trueconsole.log(a.has('three')) //false 5.map.clear()，清空所有数据，没有返回12const a = new Map([['one',1],['two',2]])a.clear() 6.set.keys()返回key的遍历器12const a = new Map([['one',1],['two',2]])a.keys() 6.set.values()返回value的遍历器12const a = new Map([['one',1],['two',2]])a.values() 6.set.entries()返回键值对的便利器12const a = new Map([['one',1],['two',2]])a.entries() 7.set.forEach()使用回调函数遍历每个成员1234const a = new Map([['one',1],['two',2]])a.forEach(function(value,key,map)&#123; console.log(value,key,map)//有3个参数&#125;)]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set数据结构]]></title>
    <url>%2F2018%2F04%2F19%2Fes6-3%2F</url>
    <content type="text"><![CDATA[创建set123const a = new Set();const a = new Set([1,2,3])//可以传参数 set的属性,返回set数据里的个数console.log(a.size) //3 set的方法1.set.add(value)添加一个数据，返回set本身结构,可以链式添加12345a.add(4);console.log(a) //1,2,3,4a.add(5).add(6).add(7);console.log(a) //1,2,3,4,5,6,7 2.set.delete(value)删除指定数据，返回一个布尔值，表示是否删除成功12345console.log(a.delete(1)); //trueconsole.log(a) //2,3,4,5,6,7//再次执行删除console.log(a.delete(1)); //false 上面已经删除过了1,所有删除失败 3.set.has(value)判断set数据里是否包含改值，返回一个布尔值12console.log(a.has(1)); //falseconsole.log(a.has(2)); //true 4.set.clear()清楚结构中所有的数据，没有返回12a.clear()console.log(a) //被清空 5.set.keys()和set.values() 返回兼职的遍历器，因为set的key和value的值是一样的，所有两个方法返回的值是相同的123const b = new Set([1,2,3]);b.keys()b.value() 6.set.entries()返回键值对的便利器12const c = new Set([1,2,3]);c.entries() 7.set.forEach()使用回调函数遍历每个成员1234const d = new Set([1,2,3,4])d.forEach(function(value,key,set)&#123; console.log(value,key,set)//有3个参数&#125;) set不允许有重复的数据12const d = new Set([1,2,3,4])d.add(4)]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>javascript</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量的解析赋值]]></title>
    <url>%2F2018%2F04%2F19%2Fes6-2%2F</url>
    <content type="text"><![CDATA[数组的结构赋值12345678910111213141516171819let a = 1;let b = 2;let c = 3;console.log(a,b,c) //1,2,3let [a,b,c] = [1,2,3]console.log(a,b,c) //1,2,3let[a,[[b],c]] = [1,[[2],3]];console.log(a,b,c) //1,2,3 匹配对等的值let [,,c] = [1,2,3]console.log(c) //3let [a] = [];console.log(a) //undefinedlet [a = 1] = [];console.log(a) //1,默认赋值 对象的结构赋值123456let &#123;a,b&#125; = &#123;b : 1,a : 2&#125;;console.log(a,b) //2,1let &#123;a : b&#125; = &#123;a : 1&#125;console.log(b) //1console.log(a) //a is not defined 基本类型的结构赋值1234567891011121314let [a,b,c] = '1,2,3';console.log(a,b,c) //1,2,3let &#123;toString : ts&#125; = 1;let &#123;toString : bs&#125; = true;console.log(ts === Number.prototype.toString) //trueconsole.log(ts === Boolean.prototype.toString) //truelet &#123;length : len&#125; = 'liuguangkuo'console.log(len) //11null和undefined不能进行结构赋值let [a] = null //错误let [b] = undefined //错误]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>let</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6 let和const]]></title>
    <url>%2F2018%2F04%2F19%2Fes6-1%2F</url>
    <content type="text"><![CDATA[let的使用1.使用let声明的变量只在命令所在的代码块内有效123456&#123; let a = 1; var b = 2;&#125;console.log(a) // a is not definedconsole.log(b) // 2 2.使用let声明的变量在域解析的时候不会被提升123456789101112console.log(a) //a is not definedlet a = 1;console.log(b) //undefinedvar b = 2;let c = 3;function test()&#123; c = 10; //c is not defined(暂时性死去) let c = 20;&#125;test() 3.let不允许在同一个作用域下声明已经声明过的变量12345var a = 0;let a = 1; //错误let b = 0;let b = 1;//错误 4.let在for循环中的使用12345678910111213141516171819202122232425262728&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;var lis = document.querySelectorAll('li');for(var i = 0;i &lt; lis.length;i++)&#123; lis[i].onclick = function()&#123; console.log(i) &#125;&#125;返回结果：点击后console的结果都是5for(let i = 0;i &lt; lis.length;i++)&#123; lis[i].onclick = function()&#123; console.log(i) &#125;&#125;返回结果：console.log(0)console.log(1)console.log(2)console.log(3)console.log(4) 123456789for(let i = 0;i &lt; 3;i++)&#123; let i = 10; console.log(i)&#125;console.log(i)返回结果：3次10i is not defined const的使用const具备和let的1、2、3条特点，1，常量只在命令所在的代码块内有效、2，常量在域解析的时候不会被提升、3，不能同一个作用域下声明已经声明过的常量 1.声明的时候必须赋值123var a;let b;const c;//错误 2.声明的常量存储基本数据类型的时候不可以更改其数据类型。如果存储的是对象，那么引用不可以改变，至于对象的数据，如何变化是没有关系的。123456const a = 1;a = '1'// 错误const obj = &#123;b : 20&#125;obj.b = 200;console.log(obj.b) // 200]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>let</tag>
        <tag>const</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript DOM节点类型]]></title>
    <url>%2F2018%2F04%2F18%2FnodeType%2F</url>
    <content type="text"><![CDATA[JavaScript中所有HTML DOM节点类型都继承自Node类型，因此所有类型的节点都有一些相同的属性和方法。Node接口是DOM1级中定义的一个接口，在JavaScript中Node接口被实现为Node类型。 每个节点都有nodeType属性，该属性表示节点类型。在浏览器使用console.dir(Node)查看： 这些类型中，有些节点可以包含子节点，有些没有子节点，详细如下： 节点类型 描述 子节点 Element 代表元素 Element, Text, Comment, ProcessingInstruction, CDATASection, EntityReference Attr 代表属性 Text, EntityReference Text 代表元素或属性中的文本内容 None CDATASection 代表文档中的 CDATA 部（不会由解析器解析的文本） None EntityReference 代表实体引用 Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference Entity 代表实体 Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference ProcessingInstruction 代表处理指令 None Comment 代表注释 None Document 整个文档，DOM树 Element, ProcessingInstruction, Comment, DocumentType DocumentType 向为文档定义的实体提供接口 None DocumentFragment 代表轻量级的 Document 对象（文档的某个部分） Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference Notation 代表 DTD 中声明的符号 None 常用节点类型 类型 常量 nodeType nodeName Element类型 ELEMENT_NODE 1 元素的标签名 Text类型 TEXT_NODE 3 #text Document类型 DOCUMENT_NODE 9 #document DocumentFragment类型 DOCUMENTFRAGMENT_NODE 11 #document-fragment]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>节点类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3帧动画-animation]]></title>
    <url>%2F2018%2F03%2F30%2Fanimation%2F</url>
    <content type="text"><![CDATA[一、什么是帧动画？前面提到补间动画，只能定制动画的两个状态，也就是开始和介绍状态。但是帧动画就能控制到每一帧的动画，从而做出更为复杂的动画。 二、animation的属性12345678animation-name 规定需要绑定到选择器的 keyframe 名称。。animation-duration 规定完成动画所花费的时间，以秒或毫秒计。animation-timing-function 规定动画的速度曲线。animation-delay 规定在动画开始之前的延迟。animation-iteration-count 规定动画应该播放的次数。animation-direction 规定是否应该轮流反向播放动画。animation-fill-mode 规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式animation-play-state 指定动画是否正在运行或已暂停。 animation-name属性animation-name规定需要绑定到选择器的 keyframe 名称。123.box &#123; animation-name: keyframe | none;&#125; 12keyframe 规定需要绑定到选择器的 keyframe 的名称。none 规定无动画效果（可用于覆盖来自级联的动画）。 keyframe语法:12345@keyframes changeBg &#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125; 上面代码表示，changeBg效果一共有三个状态，分别为起始（0%）、中点（50%）和结束（100%）。如果有需要，完全可以插入更多状态。 animation-duration属性animation-duration规定完成动画所花费的时间，以秒或毫秒计。123.box &#123; animation-duration: time;&#125; 1time 规定完成动画所花费的时间。默认值是 0，意味着没有动画效果。 animation-timing-function属性animation-timing-function规定速度效果的速度曲线。1animation-timing-function: linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(n,n,n,n); 123456linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。ease 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 更多cubic-bezier自定义，查看http://cubic-bezier.com/ animation-delay属性animation-delay定义过渡效果何时开始。123.box &#123; animation-delay: time;&#125; 1time 可选。定义动画开始前等待的时间，以秒或毫秒计。默认值是 0。 animation-iteration-count属性animation-iteration-count规定动画应该播放的次数。123.box &#123; animation-iteration-count: n|infinite;&#125; 12n 定义动画播放次数的数值。infinite 规定动画应该无限次播放。 animation-direction属性animation-direction规定是否应该轮流反向播放动画。123.box &#123; animation-direction: normal | alternate;&#125; 12normal 默认值。动画应该正常播放。alternate 动画应该轮流反向播放。 animation-fill-mode属性animation-fill-mode属性规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。123.box &#123; animation-fill-mode: none | forwards | backwards | both | initial | inherit;&#125; 123456none 默认值。动画在动画执行之前和之后不会应用任何样式到目标元素。forwards 在动画结束后,停留在结束的位置（由 animation-iteration-count 决定），动画将应用该属性值。backwards 让动画回到第一帧的状态。both 动画遵循 forwards 和 backwards 的规则。也就是说，动画会在两个方向上扩展动画属性。initial 设置该属性为它的默认值。请参阅 initial。inherit 从父元素继承该属性。请参阅 inherit。 animation-direction属性animation-direction规定是否应该轮流反向播放动画。123.box &#123; animation-direction: normal | alternate;&#125; 12normal 默认值。动画应该正常播放。alternate 动画应该轮流反向播放。 animation 属性transition属性是animation-name, animation-duration , animation-timing-function, animation-delay, animation-iteration-count , animation-direction , animation-fill-mode和 animation-play-state的简写，默认值为none 0 ease 0 1 normal none running。123.box &#123; animation: name duration timing-function delay iteration-count direction fill-mode play-state;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>动画</tag>
        <tag>animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3补间动画-transition]]></title>
    <url>%2F2018%2F03%2F30%2Ftransition%2F</url>
    <content type="text"><![CDATA[一、什么是补间动画？补间动画，顾名思义，就是补齐中间状态的一种动画。补间动画我们可以控制两个状态，就是开始状态和介绍状态，中间的状态是由浏览器自动帮忙计算填补。 二、transition的属性1234transition-property 规定设置过渡效果的 CSS 属性的名称。transition-duration 规定完成过渡效果需要多少秒或毫秒。transition-timing-function 规定速度效果的速度曲线。transition-delay 定义过渡效果何时开始。 transition-property属性transition-property规定设置过渡效果的 CSS 属性的名称。123.box &#123; transition-property: all ｜ none | property;&#125; 123all 默认值，所有属性都将获得过渡效果。none 没有属性会获得过渡效果。property 定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。 不是所有的css属性都支持transition动画，不支持的属性如下：123456background-images //a.jpg -&gt; b.jpgfloat //none -&gt; leftwidth/height //auto -&gt; 100px(不支持)，10px -&gt; 100px(支持)display //none -&gt;blockvisibility //hidden -&gt; visibleposition // static -&gt; absolute transition-duration属性transition-duration规定完成过渡效果需要多少秒或毫秒。123.box &#123; transition-duration: time;&#125; 1time 规定完成过渡效果需要花费的时间（以秒或毫秒计）,默认值是 0，意味着不会有效果。 transition-timing-function属性transition-timing-function规定速度效果的速度曲线。1transition-timing-function: linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(n,n,n,n); 123456linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。ease 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 更多cubic-bezier自定义，查看http://cubic-bezier.com/ transition-delay属性transition-delay定义过渡效果何时开始。123.box &#123; transition-delay: time;&#125; 1time 规定在过渡效果开始之前需要等待的时间，以秒或毫秒计。,默认值是 0 transition 属性transition属性是transition-property, transition-duration , transition-timing-function 和 transition-delay的简写，默认值为all 0 ease 0。123.box &#123; transition: property duration timing-function delay;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>动画</tag>
        <tag>transition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3布局－flex]]></title>
    <url>%2F2018%2F03%2F30%2Fflex%2F</url>
    <content type="text"><![CDATA[以下内容主要来源于：阮一峰的网络日志 浏览器支持 Chrome Safari Firefox Opera IE Android iOS 21+ 6.1+ 22+ 12.1+ 10+ 4.4+ 7.1+ PC端不建议使用，毕竟ie7-ie9还有差不多15%的市场份额，更多兼容查看：Can I use 一、什么是flex布局？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。可以使用Flexbox实时代码演示帮助学习，但是该网站链接了google的cdn文件，要梯子、要梯子、要梯子。 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。123.box&#123; display: inline-flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴main axis和垂直的交叉轴cross axis。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上。123456flex-direction //属性决定主轴的方向（即项目的排列方向）flex-wrapflex-flowjustify-contentalign-itemsalign-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 1234row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。（1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。12345flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。12345flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。flex-wrap属性为nowrap，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。123456flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 四、flex-item的属性以下6个属性设置在项目上。123456orderflex-growflex-shrinkflex-basisflexalign-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;;&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，以上图为例，3个容器，把剩余空间分成4等份，flex-grow属性为2的容器占据2等份。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小，其他等比缩小。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。123.item &#123; flex-basis: &lt;length&gt; | auto;&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none(0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>布局</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML meta标签大全]]></title>
    <url>%2F2017%2F09%2F25%2FhtmlMeta%2F</url>
    <content type="text"><![CDATA[前文刚写完doctype，现在来学习关于meta，再写html的时候，最长用到的就是，但是meta不止这一个属性，下面来好好的了解了解meta meta的作用meta常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务。语法：1&lt;meta name="参数" content="具体的参数值"&gt; 可选的属性 属性 值 描述 html4 html5 charset character encoding 定义文档的字符编码。 × √ content some_text 定义与 http-equiv 或 name 属性相关的元信息。 √ √ http-equiv content-typeexpiresrefreshset-cookie 把 content 属性关联到 HTTP 头部。 √ √ name authordescriptionkeywordsgeneratorrevisedothers 把 content 属性关联到一个名称。 √ √ scheme some_text 定义用于翻译 content 属性值的格式。 √ × http-equiv属性http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容 content-Type说明：用于设定网页字符集，便于浏览器解析与渲染页面12&lt;meta http-equiv="content-Type" content="text/html;charset=utf-8"&gt; //不推荐使用&lt;meta charset="utf-8"&gt; //HTML5设定网页字符集的方式，推荐使用UTF-8 expires网页到期时间说明:用于设定网页的到期时间，过期后网页必须到服务器上重新传输。1&lt;meta http-equiv="expires" content="Sunday 26 October 2016 01:00 GMT" /&gt; refresh自动刷新并指向某页面说明:网页将在设定的时间内，自动刷新并调向设定的网址。1&lt;meta http-equiv="refresh" content="2；URL=http://www.baidu.com/"&gt; //2秒后跳转百度 Set-Cookie说明:如果网页过期。那么这个网页存在本地的cookies也会被自动删除。12&lt;meta http-equiv="Set-Cookie" content="name, date"&gt; //格式&lt;meta http-equiv="Set-Cookie" content="User=liuguangkuo; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT"&gt; //具体范例 name属性author说明:用于标注网页作者1&lt;meta name="author" content="liuguangkuo"&gt; description说明:页面描述，用于搜索引擎收录1&lt;meta name="description" content="这是刘广阔的个人博客"&gt; keywords说明:页面关键词，用于被搜索引擎收录1&lt;meta name="keywords" content="刘广阔，博客，前端"&gt; generator说明:用于标注网页制作软件1&lt;meta name="generator" content="atom"&gt; revised说明:网页文档的修改时间1&lt;meta name="revised" content="刘广阔的博客, 2017/10/10"/&gt; 移动端metaviewport说明:能优化移动浏览器的显示。如果不是响应式网站，不要使用initial-scale或者禁用缩放。12&lt;meta name ="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui"&gt; viewport content参数解释：width viewport 宽度(数值/device-width)height viewport 高度(数值/device-height)initial-scale 初始缩放比例(范围从&gt;0到10)maximum-scale 最大缩放比例minimum-scale 最小缩放比例user-scalable 是否允许用户缩放(yes/no)minimal-ui iOS 7.1 beta 2 中新增属性，可以在页面加载时最小化上下状态栏。这是一个布尔值，可以直写minimal-ui ios设备说明:添加到主屏后的标题1&lt;meta name="apple-mobile-web-app-title" content="刘广阔的博客"&gt; 说明:是否启用 WebApp 全屏模式（需添加到主屏后有效，浏览器打开无效）1&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; 说明:添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）1&lt;meta name="apple-itunes-app" content="app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL"&gt; 说明:设置苹果工具栏颜色1&lt;meta name="apple-mobile-web-app-status-bar-style" content="black"/&gt; 只有在 apple-mobile-web-app-capable&quot; content=&quot;yes&quot; 时生效content 参数：default 默认值。black 状态栏背景是黑色。black-translucent 状态栏背景是黑色半透明。如果设置为 default 或 black ,网页内容从状态栏底部开始。如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。 说明:忽略页面中的数字识别为电话，忽略email识别1&lt;meta name="format-detection" content="telphone=no, email=no"/&gt;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>meta</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识HTML的DOCTYPE]]></title>
    <url>%2F2017%2F09%2F18%2FhtmlDoctype%2F</url>
    <content type="text"><![CDATA[一直想回顾回顾以前的基础知识，刚好最近参加了腾讯imweb课堂的学习，从零开始再次学习，开始整理一系列学习笔记。前端工程师的三个必会技能html、css、javascript,咱先从html开始。 什么是DOCTYPE?在学习HTML文档初，第一段代码往往是&lt;!DOCTYPE html&gt;，那么什么是&lt;!DOCTYPE html&gt;，它又有意义是什么呢？&lt;!DOCTYPE&gt;不是HTML标签。它为浏览器提供一项信息（声明），即HTML是用什么版本编写的。&lt;!DOCTYPE&gt;声明必须位于HTML5文档中的第一行，也就是位于&lt;html&gt;标签之前。HTML有多个不同的版本，该标签告知浏览器文档所使用哪种HTML规范，从而正确的显示网页。 HTML版本HTML也有多个不同的版本，只有完全明白页面中使用的确切HTML版本，浏览器才能完全正确地显示出HTML页面。现在常用的版本为HTML5，声明就是&lt;!DOCTYPE html&gt;，没个版本又不同的声明，下面是HTML版本的列表: 版本 年份 HTML 1991 HTML2.0 1995 HTML3.2 1997 HTML4.01 1999 XHTML1.0 2000 HTML5 2012 XHTML5 2013 常见的 DOCTYPE 声明HTML51&lt;!DOCTYPE html&gt; HTML 4.01 Strict这个 DTD 包含所有 HTML 元素和属性，但不包括表象或过时的元素（如 font ）。框架集是不允许的。1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; HTML 4.01 Transitional这个 DTD 包含所有 HTML 元素和属性，包括表象或过时的元素（如 font ）。框架集是不允许的。1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; HTML 4.01 Frameset这个 DTD 与 HTML 4.01 Transitional 相同，但是允许使用框架集内容。1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"&gt; XHTML 1.0 Strict该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。12&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; XHTML 1.0 Transitional该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。12&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; XHTML 1.0 Frameset该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。12&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt; XHTML 1.1该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt; 关于HTML 有效DOCTYPES，点击查看]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>doctype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js replace方法替换变量]]></title>
    <url>%2F2017%2F07%2F25%2Fjs-replace%2F</url>
    <content type="text"><![CDATA[使用editor编辑器，添加图的时候使用的是相对路径，但是客户端直接把这块呈现在页面里，导致图片打不开，从而考虑在编辑文本的时候在原来文本的url前添加域名，但是replace无法直接替换变量，看了些资料后找到了解决方法，如下： 12345//替换第一个astring.replace('a','b')//替换全部astring.replace(/a/g,'b')&#125;) 但是我的后台分测试服务器及线上服务器，所有需要替换的值是一个变量:12var host = 'www.a.com'string.replace(host,'b') 这样写，可以替换第一个，到那时无法替换全部，然后改成：12var host = 'www.a.com'string.replace(/host/g,'b') 这样写，无法替换，解决方法为：12var host = 'www.a.com'string.replace(new RegExp(host,'g'),'b')]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>replace</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-express生成Excel文件]]></title>
    <url>%2F2017%2F07%2F21%2Fexpress-excel%2F</url>
    <content type="text"><![CDATA[自从公司开通了商城后，时常要查看每天的销售情况，又因为货都是供应商发送，需要提供每天的订单信息给到供应商，所有需要发每天的数据生产一个excel文件。 使用的是excel-export模块，下面介绍使用方法。1npm install excel-export 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var nodeExcel = require('excel-export');router.get('/downloadExcel',function(req,res)&#123; var tabelHead = [&#123; caption:'用户id' &#125;,&#123; caption:'购买渠道' &#125;,&#123; caption:'商品id' &#125;,&#123; caption:'商品名称' &#125;,&#123; caption:'收货人' &#125;,&#123; caption:'手机号码' &#125;,&#123; caption:'地址' &#125;,&#123; caption:'备注' &#125;,&#123; caption:'快递单号' &#125;,&#123; caption:'资料填写时间' &#125;,&#123; caption:'订单时间' &#125;,&#123; caption:'价格' &#125; ]; request.post(&#123;url:'地址', form: &#123;&#125;&#125;, function(err,httpResponse,body)&#123; var arrBox = []; var result = JSON.parse(body); for(var i = 0;i &lt; result.data.length;i++)&#123; var arr = []; for(j in result.data[i])&#123; var val = result.data[i][j] arr.push(val) &#125; arrBox.push(arr) &#125; var configuration = &#123;&#125;; configuration.cols= tabelHead; //标题 configuration.rows = arrBox; //内容 var result=nodeExcel.execute(configuration); res.setHeader('Content-Type','application/vnd.openxmlformates'); res.setHeader("Content-Disposition","attachment;filename="+"file_name.xlsx"); res.end(result,'binary'); &#125;)&#125;); 效果如下：]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ueditor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap datetimepicker浏览器卡死]]></title>
    <url>%2F2017%2F07%2F19%2Fbootstrap-datetimepicker%2F</url>
    <content type="text"><![CDATA[最近在做后台系统文章管理的时候遇到了个小问题，后台采用bootstrap搭建，然后里面有个需求需要用到时间控件，所有使用了datetimepicker，然后出现了多个选择框的时候，浏览器卡死的问题，具体如下： 文章列表页面需要给单个文章修改上架时间的功能，在页面初始化加载的时候，运行了：1234567$('.demo').datetimepicker(&#123; format: 'yyyy-mm-dd hh:ii:ss', language: 'zh-CN', todayHighlight : true, autoclose : true, todayBtn: true&#125;) 第一个问题：当翻页的时候，新加载的input没有得到渲染，所有选择没有效果。 解决方法：要在ajax的success重新渲染列表后重新再一次的初始化input。 第二个问题：当多翻页几次之后，浏览器竟然卡死了，起初还以为电脑问题，后来排查发现就这个多次初始化input问题。我的列表页，一页有20条数据，一次创建20个时间选择器，最后导致页面卡死。 解决方法：在重新渲染之前删除多余的选择器12345678$('.datetimepicker').remove();$('.demo').datetimepicker(&#123; format: 'yyyy-mm-dd hh:ii:ss', language: 'zh-CN', todayHighlight : true, autoclose : true, todayBtn: true&#125;) 页面如下：]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
        <tag>datetimepicker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ueditor自定义弹出框]]></title>
    <url>%2F2017%2F07%2F13%2Ffit-editor%2F</url>
    <content type="text"><![CDATA[最近公司产品上线了商城模块，为了方便推广，需要在文章里添加一个商品的信息，点击跳转都对应的商品详情页面，文章的编辑器使用的是百度的ueditor，看了下文档，可以使用自定义弹出框来实现这个效果。 第一步找到ueditor.config.js文件中的toolbars的数组，增加一个mydialog,然后找到labelMap对象，添加&#39;mydialog&#39;:&#39;测试&#39;,如果不需要全局也可以对单独文件添加 12345678var ue = UE.getEditor('container',&#123; toolbars: [ ['source', 'undo', 'redo', 'bold','link','unlink','simpleupload','insertimage','fontsize','paragraph','forecolor','mydialog'] ], labelMap : &#123; 'mydialog' : '测试' &#125;&#125;); 第二步找到dialogs文件，新建mydialog文件夹，然后在文件夹里新建mydialog.html文件，这个文件自定义页面的代码，任何编辑修改都在这里，如参考ling/link.html文件。 第三步找到ueditor.all.js文件，搜索btnCmds,在数组里添加mydialog。1234567var btnCmds = ['undo', 'redo', 'formatmatch', 'bold', 'italic', 'underline', 'fontborder', 'touppercase', 'tolowercase', 'strikethrough', 'subscript', 'superscript', 'source', 'indent', 'outdent', 'blockquote', 'pasteplain', 'pagebreak', 'selectall', 'print','horizontal', 'removeformat', 'time', 'date', 'unlink', 'insertparagraphbeforetable', 'insertrow', 'insertcol', 'mergeright', 'mergedown', 'deleterow', 'deletecol', 'splittorows', 'splittocols', 'splittocells', 'mergecells', 'deletetable', 'drafts','mydialog']; 搜索iframeUrlMap,把第二步中的的文件路径加进去。12345var iframeUrlMap = &#123; //... 'charts': '~/dialogs/charts/charts.html', 'mydialog': '~/dialogs/mydialog/mydialog.html'&#125;; 搜索dialogBtns,在ok属性中添加mydialog。12345var dialogBtns = &#123; noOk:['searchreplace', 'help', 'spechars', 'webapp','preview'], ok:['attachment', 'anchor', 'link', 'insertimage', 'map', 'gmap', 'insertframe', 'wordimage', 'insertvideo', 'insertframe', 'edittip', 'edittable', 'edittd', 'scrawl', 'template', 'music', 'background', 'charts','mydialog'] &#125;; 修改自己icon图标，找到themes/default/images/icons.png文件，添加自己的图片到文件中，然后使用背景定位来选中自己的图片.找到themes/default/css/ueditor.css,添加代码:123.edui-default .edui-for-mydialog .edui-icon &#123; background-position: -123px -76px&#125; 这个时候点击自己添加好的图片就能有效果了，具体逻辑在mydialog.html中编写，如图：点击确定使用 dialog.onok方法123dialog.onok = function ()&#123; //确定后运行的代码&#125;; 这个时候以为已经好了，但是当使用editor.execCommand(&#39;insertHtml&#39;,&#39;内容&#39;);到编辑器的时候发现div等一些标签被ueditor被过滤掉了。解决方法如下： 一1234me.setOpt(&#123; 'allowDivTransToP':false,//true改成false 'disabledTableInTable':true&#125;); 二找到me.addInputRule方法，注销case style、script12345678910case &apos;style&apos;:case &apos;script&apos;: node.setAttr(&#123; cdata_tag: node.tagName, cdata_data: (node.innerHTML() || &apos;&apos;), &apos;_ue_custom_node_&apos;:&apos;true&apos; &#125;); node.tagName = &apos;div&apos;; node.innerHTML(&apos;&apos;); break; 三找到me.addOutputRule方法，注销switch12345678910111213141516171819202122232425262728293031switch (node.tagName) &#123; case &apos;div&apos;: if (val = node.getAttr(&apos;cdata_tag&apos;)) &#123; node.tagName = val; node.appendChild(UE.uNode.createText(node.getAttr(&apos;cdata_data&apos;))); node.setAttr(&#123;cdata_tag: &apos;&apos;, cdata_data: &apos;&apos;,&apos;_ue_custom_node_&apos;:&apos;&apos;&#125;); &#125; break; case &apos;a&apos;: if (val = node.getAttr(&apos;_href&apos;)) &#123; node.setAttr(&#123; &apos;href&apos;: utils.html(val), &apos;_href&apos;: &apos;&apos; &#125;) &#125; break; break; case &apos;span&apos;: val = node.getAttr(&apos;id&apos;); if(val &amp;&amp; /^_baidu_bookmark_/i.test(val))&#123; node.parentNode.removeChild(node) &#125; break; case &apos;img&apos;: if (val = node.getAttr(&apos;_src&apos;)) &#123; node.setAttr(&#123; &apos;src&apos;: node.getAttr(&apos;_src&apos;), &apos;_src&apos;: &apos;&apos; &#125;) &#125;&#125; 最后因为最后文章是在app里呈现，这样的话就需要适配各种手机，这个时候在插入html的时候不能把样式写入到html，但是又要保证在后台能看到设计的效果，就这个2套样式，一套是app的样式，一套是在ueditor自己的样式，目录在themes/iframe.css，需要为了保持在后台显示的效果和前台一样。后台如图：app效果： 其他问题记录修改字体颜色找到ueditor.all.js文件，搜索COLORS,把原有颜色修改成自己需要的颜色。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ueditor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整理常用正则表达式]]></title>
    <url>%2F2017%2F07%2F05%2Fregexp%2F</url>
    <content type="text"><![CDATA[校验数字的表达式12345678910111213141516171819数字：^[0-9]*$n位的数字：^\d&#123;n&#125;$至少n位的数字：^\d&#123;n,&#125;$m-n位的数字：^\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$非负整数：^\d+$ 或 ^[1-9]\d*|0$非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 校验字符的表达式1234567891011汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$长度为3-20的所有字符：^.&#123;3,20&#125;$由26个英文字母组成的字符串：^[A-Za-z]+$由26个大写英文字母组成的字符串：^[A-Z]+$由26个小写英文字母组成的字符串：^[a-z]+$由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$可以输入含有^%&amp;',;=?$\"等字符：[^%&amp;',;=?$\x22]+禁止输入含有~的字符：[^~\x22]+ 特殊需求表达式123456789101112131415161718192021222324Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$中文字符的正则表达式：[\u4e00-\u9fa5]双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))空白行的正则表达式：\n\s*\r (可以用来删除空白行)HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 本文来源于网上，未找到出处！]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一张图了解sass]]></title>
    <url>%2F2017%2F07%2F04%2FsassMap%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>sass</category>
      </categories>
      <tags>
        <tag>sass</tag>
        <tag>scss</tag>
        <tag>css</tag>
      </tags>
  </entry>
</search>